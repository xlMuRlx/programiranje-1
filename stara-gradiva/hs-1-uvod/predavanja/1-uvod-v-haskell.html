<!DOCTYPE html>
<html>
  <head>
    <title>Uvod v Haskell</title>
    <meta charset="utf-8">
    <style>
      body {
        font-family: 'Avenir Next';
      }
      h3 {
        font-weight: normal;
      }
      .remark-code, .remark-inline-code {
        font-family: 'Menlo';
      }
      .remark-code {
        font-size: 1.5em;
      }
      ol, ul {
        font-size: 1.5em;
      }

      a.reveal {
        font-weight: bold;
      }

      a.reveal:hover {
        cursor:pointer;
      }

      .question {
        color: white;
        background-color: black;
      }

      .red {
        color: red;
      }

      .green {
        color: green;
      }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Programiranje 1

## Uvod v Haskell

### 7. november 2016

---

class: center, middle

## Osnove

---

### Aritmetične operacije so podobne Pythonovim

```haskell
λ> 12 * (34 + 67) - 89
1123

λ> 22 / 7
3.142857142857143

λ> 12 ** 34
4.922235242952027e36

λ> 12 ^ 34
4922235242952026704037113243122008064
```

---

### Logične operacije so podobne Pythonovim

```haskell
λ> True || False
True

λ> False && not (False || True)
False

λ> if True then 10 else 20
10
```

---

### Primerjave so podobne Pythonovim

```haskell
λ> 1 == 2
False

λ> 1 /= 2
True

λ> 1 < 2
True

λ> 1 >= 2
False
```

---

### Argumente funkcij pišemo brez oklepajev

```haskell
λ> sin pi
1.2246467991473532e-16

λ> min 9 10
9

λ> sin 2 * pi
2.856642116043664

λ> sin (2 * pi)
-2.4492935982947064e-16

λ> sin 3 + log 10 - min 2 6
0.44370510105391325
```

---

### Funkcije kličemo infiksno ali prefiksno

```haskell
λ> 1 + 2
3

λ> (+) 1 2
3

λ> mod 12345 678
141

λ> 12345 `mod` 678
141
```

---

### Sezname sestavljamo na veliko načinov

```haskell
λ> [1,2] ++ [3,4]
[1,2,3,4]

λ> 1 : 2 : [3,4]
[1,2,3,4]

λ> [1,2] : [[3,4,5],[6,7]] ++ [[8,9]]
[[1,2],[3,4,5],[6,7],[8,9]]

λ> [1..10]
[1,2,3,4,5,6,7,8,9,10]

λ> [1,3..10]
[1,3,5,7,9]
```

---
class: question
### Kateri seznami so pravilno sestavljeni?

* `[1,2] : [3,4]` .red.spoiler[NE]
* `1 : 2 : 3 : []` .green.spoiler[DA]
* `[1,2] ++ [3,4]` .green.spoiler[DA]
* `1 ++ 2 ++ [3]` .red.spoiler[NE]
* `1 : 2 : 3` .red.spoiler[NE]
* `1 : [2,3] + []` .red.spoiler[NE]
* `[1] ++ [2] ++ [3]` .green.spoiler[DA]
* `[1,2] ++ []` .green.spoiler[DA]
* `[1,2] : []` .green.spoiler[DA]

---

### Obstaja cel kup funkcij za sezname.

```haskell
λ> sum [1,2,3,4]
10

λ> 5 `elem` [1,2,3,4]
False

λ> take 2 [1,2,3,4]
[1,2]

λ> reverse (take 5 (reverse [1..100]))
[96,97,98,99,100]

λ> reverse $ take 5 $ reverse [1..100]
[96,97,98,99,100]
```

---

### Nizi so seznami znakov

```haskell
λ> ['A','B','C']
"ABC"

λ> 'A' : 'B' : ['C','D'] ++ "EFG"
"ABCDEFG"

λ> reverse "Perica reže raci rep"
"per icar ežer acireP"

λ> length "disproporcioniranost"
20

λ> ['a'..'z']
"abcdefghijklmnopqrstuvwxyz"
```

---

### Izpeljani seznami

```haskell
λ> [n^2 | n <- [1..10]]
[1,4,9,16,25,36,49,64,81,100]

λ> [n | n <- [1..50], n `mod` 7 == 0]
[7,14,21,28,35,42,49]

λ> [m * n | m <- [1,2,3], n <- [10,100]]
[10,100,20,200,30,300]

λ> [z | z <- "lokomotiva", z /= 'o']
"lkmtiva"
```

---

### Nabori

```haskell
λ> fst (True, 'a')
True

λ> zip [1,2,3] "abc"
[(1,'a'),(2,'b'),(3,'c')]

λ> [True, 'a']
<interactive>:34:8:
    Couldn't match expected type ‘Bool’ 
      with actual type ‘Char’
```

---

### Vrednosti v konzoli definiramo z `let`

```haskell
λ> let x = 6

λ> let zmnozi x y = x * y

λ> zmnozi x (x + 1)
42
```

---

### Več definicij shranimo v datoteko

- - -

`odgovor.hs`

```haskell
x = 6

zmnozi x y = x * y
```

- - -

```haskell
λ> :load odgovor.hs
[1 of 1] Compiling Main
Ok, modules loaded: Main.

λ> zmnozi x (x + 1)
42
```

---

### Funkcije lahko definiramo po kosih

```haskell
pozdravi "Matija" =
  "Dober dan, gospod predavatelj!"
pozdravi ime =
  "Dober dan, " ++ ime ++ "!"
```

```haskell
λ> pozdravi "Urban"
"Dober dan, Urban!"

λ> pozdravi "Philipp"
"Dober dan, Philipp!"

λ> pozdravi "Matija"
"Dober dan, gospod predavatelj!"
```

---

### Vrstni red definicij je pomemben

```haskell
pozdravi ime =
  "Dober dan, " ++ ime ++ "!"
pozdravi "Matija" =
  "Dober dan, gospod predavatelj!"
```

```haskell
funkcije.hs:1:1: Warning:
    Pattern match(es) are overlapped
    In an equation for ‘pozdravi’:
      pozdravi "Matija" = ...

λ> pozdravi "Matija"
"Dober dan, Matija!"
```

---

### Zajeti moramo vse primere

```haskell
pozdravi "Matija" =
  "Dober dan, gospod predavatelj!"
pozdravi "Urban" =
  "Dober dan, gospod asistent!"
```

```haskell
λ> pozdravi "Philipp"
"*** Exception: funkcije.hs:(1,1)-(2,47):
  Non-exhaustive patterns
  in function pozdravi
```

---

### Na definicije lahko dodamo stranske pogoje

```haskell
ocena 100 = "fantastično, 10/10"
ocena tocke
    | tocke >= 90 = "odlično, 10"
    | tocke >= 80 = "prav dobro, 9"
    | tocke >= 70 = "prav dobro, 8"
    | tocke >= 60 = "dobro, 7"
    | tocke >= 50 = "zadostno, 6"
    | otherwise = "nezadostno"
```

```haskell
λ> ocena 85
"prav dobro, 9"

λ> ocena 30
"nezadostno"
```

---

### `otherwise` je le sinonim za `True`

```haskell
sicer = True
ocena 100 = "fantastično, 10/10"
ocena tocke
    | tocke >= 90 = "odlično, 10"
    | tocke >= 80 = "prav dobro, 9"
    | tocke >= 70 = "prav dobro, 8"
    | tocke >= 60 = "dobro, 7"
    | tocke >= 50 = "zadostno, 6"
    | sicer = "nezadostno"
```

```haskell
λ> ocena 30
"nezadostno"
```

---

### Pomožne definicije delamo z `where` in `let`

```haskell
kvadratna a b c
    | d < 0 =
        error "Ni ničel"
    | d == 0 =
        (p, p)
    | otherwise =
        let q = d ** 0.5 / (2 * a) in
        (p - q, p + q)
    where
    d = b ** 2 - 4 * a * c
    p = -b / (2 * a)
```

#### `let`: pred izrazi

#### `where`: za definicijami

---

### Nabore razstavimo z vzorci

```haskell
sestejVektorja a b =
  (fst a + fst b, snd a + snd b)  
```

```haskell
sestejVektorja' (x1, y1) (x2, y2) =
  (x1 + x2, y1 + y2)  
```

---

### Tudi sezname razstavljamo z vzorci

```haskell
ucbenik [] naslov =
  naslov  
ucbenik (avtor:[]) naslov =
  avtor ++ ": " ++ naslov
ucbenik (prviAvtor:_) naslov =
  prviAvtor ++ " in ostali: " ++ naslov
```

```haskell
λ> ucbenik [] "Skrivnosti podzemlja"
"Skrivnosti podzemlja"
λ> ucbenik ["Novak"] "Arheologija"
"Novak: Arheologija"
λ> ucbenik ["Kos", "Golob"] "Fizika 1"
"Kos in ostali: Fizika 1"
```

---

### Vzorce lahko uporabljamo povsod

```haskell
maxPoKomponentah xs ys =
  [max (fst p) (snd p) | p <- zip xs ys]
```

```haskell
maxPoKomponentah' xs ys =
  [max x y | (x, y) <- zip xs ys]
```

```haskell
zadnji xs = x where (x:_) = reverse xs
```

```haskell
prvi xs = let (x:_) = xs in x
```

```haskell
prvi' (x:_) = x
```

---

### Vzorce lahko tudi gnezdimo

```haskell
f [] = 0
f [(x, _), (y, z)] = x + y + z
f ((_, x):_) = 3 * x
```

```haskell
λ> f []
0
λ> f [(1, 2)]
6
λ> f [(1, 2), (3, 4)]
8
```

---

### V izrazih lahko primere ločimo s `case`

```haskell
ucbenik [] naslov =
  naslov  
ucbenik (avtor:[]) naslov =
  avtor ++ ": " ++ naslov
ucbenik (prviAvtor:_) naslov =
  prviAvtor ++ " in ostali: " ++ naslov
```

---

### V izrazih lahko primere ločimo s `case`

```haskell
ucbenik avtorji naslov =
    opisAvtorjev ++ naslov
    where
        opisAvtorjev =
            case avtorji of
            [] -> ""
            [avtor] -> avtor ++ ": "
            prviAvtor:_ ->
                prviAvtor ++ "in ostali: "
```

---

### Ponavadi so lokalne definicije lepše

```haskell
ucbenik avtorji naslov =
    opis avtorji ++ naslov
    where
        opis [] = ""
        opis [avtor] = avtor ++ ": "
        opis (prviAvtor:_) =
            prviAvtor ++ "in ostali: "
```

---

class: center, middle

## Tipi

---

### Vsak program v Haskellu ima tip

```haskell
λ> :t 3 < 5
3 < 5 :: Bool

λ> :t 'x'
'x' :: Char

λ> :t [True, False, True]
[True, False, True] :: [Bool]

λ> :t "Haskell je zakon!"
"Haskell je zakon!" :: [Char]

λ> :t ("X", True)
("X", True) :: ([Char], Bool)
```
---

### Vsak program v Haskellu ima tip

```haskell
λ> :t [('a','b'),('c','d')]
[('a','b'),('c','d')] :: [(Char, Char)]

λ> :t [('a','b'),('b','c','d')]
<interactive>:1:12:
    Couldn't match expected type
      ‘(Char, Char)’
    with actual type
      ‘(Char, Char, Char)’
```

#### Seznami: poljubna dolžina, en tip

#### Nabori: fiksna dolžina, več tipov

---

### Vsak program v Haskellu ima tip

```haskell
λ> :t not
not :: Bool -> Bool

λ> :t and
and :: [Bool] -> Bool

λ> :t (||)
(||) :: Bool -> Bool -> Bool
```

---

### Kaj je tip funkcije `(++)`?

```haskell
[Bool] -> [Bool] -> [Bool]

[Char] -> [Char] -> [Char]

[[Char]] -> [[Char]] -> [[Char]]

...
```
--

```haskell
∀α. [α] -> [α] -> [α]
```

--

```haskell
[a] -> [a] -> [a]
```
---

### Parametrični polimorfizem

```haskell
λ> :t (++)
(++) :: [a] -> [a] -> [a]

λ> :t repeat
repeat :: a -> [a]

λ> :t []
[] :: [a]

λ> :t zip
zip :: [a] -> [b] -> [(a, b)]

λ> :t take
take :: Int -> [a] -> [a]
```

---

### Haskell zna sam izračunati najbolj splošen tip.

```haskell
λ> let repek n xs =
     reverse $ take n $ reverse xs

λ> :t repek
repek :: Int -> [a] -> [a]
```

#### Funkcije vseeno vedno opremimo z deklaracijo, ki služi kot dokumentacija in poenostavi sporočila o napakah.

```haskell
zmnozi :: Integer -> Integer -> Integer
zmnozi x y = x * y
```

---

### Kaj je tip funkcije `max`?

```haskell
Integer -> Integer -> Integer

[Char] -> [Char] -> [Char]

[[Char]] -> [[Char]] -> [[Char]]
```

--

###.red[`[a] -> [a] -> [a]`]

--

```haskell
λ> max tail reverse
???
```

--

###.green[`Ord a => [a] -> [a] -> [a]`]

---

###  Tipi razreda `Ord` podpirajo urejenost

```haskell
(<) :: Ord a => a -> a -> Bool
sort :: Ord a => [a] -> [a]
```

### Tipi razreda `Eq` podpirajo enakost

```haskell
(==) :: Eq a => a -> a -> Bool
elem :: Eq a => a -> [a] -> Bool
```

### Tipi razreda `Num` podpirajo aritmetiko

```haskell
(+) :: Num a => a -> a -> a
```

---

### Tipi razreda `Show` podpirajo prikaz

```haskell
show :: Show a => a -> String
```

```haskell
λ> not

<interactive>:19:1:
    No instance for (Show (Bool -> Bool))
      (maybe you haven't applied enough
       arguments to a function?)
```

---

class: center, middle

### naslednjič...


# Rekurzija <br>&amp;<br> funkcije višjega reda


    </textarea>
    <script src="../../js/jquery-1.11.3.min.js"></script>
    <script src="../../js/remark-latest.min.js"></script>
    <script>
      $(document).ready(function() { 
      
      $("span.spoiler").hide();
      
       $('<a class="reveal">???</a>').insertBefore('.spoiler');

      $("a.reveal").click(function(){
        $(this).parent().children("span.spoiler").fadeIn(100);
        $(this).parent().children("a.reveal").hide();
      });

    }); 
        var slideshow = remark.create({
        highlightLines: true
      });
    </script>
  </body>
</html>
